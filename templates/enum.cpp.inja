// clang-format off
/* Generated code, any modifications will be overwritten */

#include <{{ headerPath }}/{{ outputName }}.h>


using namespace std::string_view_literals;


namespace {{ enum.namespace }}
{

    {{ enum.className }}::{{ enum.className }}(std::string_view str) : value(Parse(str))
    { }

    std::array<{{ enum.className }}, {{ length(enum.items) }}ul> const & {{ enum.className }}::Values() noexcept
    {
        static constexpr std::array<{{ enum.className }}, {{ length(enum.items) }}ul> values = {
{% for item in enum.items %}
            +{{ enum.className }}::{{ item.name }}{% if not loop.is_last %},{% endif %}

{% endfor %}
        };

        return values;
    }

    std::string_view {{ enum.className }}::ToString() const noexcept
    {
        switch (value)
        {
{% for item in enum.items %}
        case {{ item.name }}: return "{{ item.name }}"sv;
{% endfor %}
        }
    }

    {{ enum.className }} {{ enum.className }}::Parse(std::string_view str)
    {
        auto result = TryParse(str);
        if (!result)
        {
            MERLIN_THROW_FMT("Unable to parse {{ enum.namespace }}::{{ enum.className }} from '{}'", str);
        }

        return result.value();
    }

    std::optional<{{ enum.className }}> {{ enum.className }}::TryParse(std::string_view str)
    {
{% for item in enum.items %}
        if (str == "{{ item.string }}"sv) return +{{ enum.className }}::{{ item.name }};
{% for alt in item.alts %}
        if (str == "{{ alt }}"sv) return +{{ enum.className }}::{{ item.name }};
{% endfor %}
{% endfor %}

        return std::nullopt;
    }

}
// clang-format on